(*
 * Type Definition DSL Grammar
 * ==========================
 *
 * This grammar defines the syntax for the Typed Tables type definition
 * language. It is used to define type aliases and composite types
 * (structures) that can be stored in the database.
 *
 * The grammar is implemented using PLY (Python Lex-Yacc).
 *)


(* ========== Top-Level Structure ========== *)

schema          ::= statement_list

statement_list  ::= statement
                  | statement_list statement

statement       ::= alias_def
                  | type_def
                  | NEWLINE


(* ========== Type Alias Definition ========== *)
(*
 * Aliases create a new named type that is stored identically to its base type,
 * but in its own separate table file.
 *
 * Examples:
 *   define uuid as uint128
 *   define name as character[]
 *)

alias_def       ::= "define" IDENTIFIER "as" type_ref
                  | "define" IDENTIFIER "as" type_ref NEWLINE


(* ========== Composite Type Definition ========== *)
(*
 * Composite types define structures with named fields. Each field references
 * a value stored in another type's table.
 *
 * Examples:
 *   Person {
 *     id: uuid
 *     name
 *     age: uint8
 *   }
 *
 *   Point { x: float32  y: float32 }
 *)

type_def        ::= IDENTIFIER "{" field_list "}"
                  | IDENTIFIER "{" field_list "}" NEWLINE
                  | IDENTIFIER "{" "}"
                  | IDENTIFIER "{" "}" NEWLINE
                  | IDENTIFIER "{" NEWLINE field_list "}"
                  | IDENTIFIER "{" NEWLINE field_list "}" NEWLINE
                  | IDENTIFIER "{" NEWLINE "}"
                  | IDENTIFIER "{" NEWLINE "}" NEWLINE


(* ========== Field Definitions ========== *)
(*
 * Fields can have explicit types or implicit types (where field name = type name).
 *
 * Examples:
 *   name: character[]    -- explicit type
 *   name                 -- implicit type (type is "name")
 *)

field_list      ::= field
                  | field_list field

field           ::= IDENTIFIER ":" type_ref NEWLINE
                  | IDENTIFIER ":" type_ref
                  | IDENTIFIER NEWLINE
                  | IDENTIFIER


(* ========== Type References ========== *)
(*
 * A type reference can be a simple type name or an array type.
 *
 * Examples:
 *   uint32          -- simple type
 *   character[]     -- array type
 *)

type_ref        ::= IDENTIFIER
                  | IDENTIFIER "[" "]"


(* ========== Lexical Elements ========== *)

IDENTIFIER      ::= [a-zA-Z_][a-zA-Z0-9_]*

NEWLINE         ::= "\n"+


(* ========== Reserved Keywords ========== *)
(*
 * The following identifiers are reserved:
 *   define, as
 *)


(* ========== Built-in Primitive Types ========== *)
(*
 * The following primitive types are pre-registered:
 *
 * Type        Size (bytes)    Description
 * ----        ------------    -----------
 * bit         1               Boolean (stored as 1 byte)
 * character   4               Unicode code point (UTF-32)
 * uint8       1               Unsigned 8-bit integer
 * int8        1               Signed 8-bit integer
 * uint16      2               Unsigned 16-bit integer
 * int16       2               Signed 16-bit integer
 * uint32      4               Unsigned 32-bit integer
 * int32       4               Signed 32-bit integer
 * uint64      8               Unsigned 64-bit integer
 * int64       8               Signed 64-bit integer
 * uint128     16              Unsigned 128-bit integer
 * int128      16              Signed 128-bit integer
 * float32     4               32-bit floating point (IEEE 754)
 * float64     8               64-bit floating point (IEEE 754)
 *
 * All types can be used as array element types by appending []:
 *   uint8[], character[], float64[], etc.
 *)


(* ========== Example Schema ========== *)
(*
 * define uuid as uint128
 * define name as character[]
 * define age as uint8
 *
 * Person {
 *   id: uuid
 *   name
 *   age
 * }
 *
 * Address {
 *   street: character[]
 *   city: character[]
 *   zipcode: character[]
 * }
 *
 * Employee {
 *   person: Person
 *   address: Address
 *   salary: float64
 * }
 *)
