(*
 * TTQ (Typed Tables Query) Language Grammar
 * =========================================
 *
 * This grammar defines the syntax for TTQ, the query language used to
 * interact with Typed Tables databases. TTQ supports selecting, filtering,
 * aggregating, creating, and deleting data.
 *
 * Newlines are treated as whitespace and are not significant — queries
 * can be formatted freely across lines. Semicolons terminate queries
 * in the interactive REPL and separate queries in scripts.
 *
 * The grammar is implemented using PLY (Python Lex-Yacc).
 *)


(* ========== Top-Level Statement ========== *)
(*
 * A statement is a query followed by a semicolon, or a bare query.
 * The grammar accepts both forms. In practice, semicolons are required
 * in the interactive REPL and in scripts with multiple queries.
 *)

statement       ::= query ";"
                  | query

query           ::= select_query
                  | eval_query
                  | show_tables_query
                  | describe_query
                  | use_query
                  | create_type_query
                  | create_instance_query
                  | delete_query


(* ========== SELECT Query (with FROM) ========== *)
(*
 * The main query type for retrieving data from tables.
 * A SELECT clause is always required after FROM.
 *
 * Examples:
 *   from Person select *
 *   from Person select name, age
 *   from Person select * where age >= 18 sort by name
 *   from Person select age, count() group by age
 *)

select_query    ::= from_clause select_clause where_clause group_clause
                    sort_clause offset_clause limit_clause

from_clause     ::= "from" IDENTIFIER
                  | "from" STRING            (* for names like "character[]" *)

select_clause   ::= "select" "*"
                  | "select" field_list

field_list      ::= select_field
                  | field_list "," select_field

select_field    ::= field_path
                  | field_path "[" array_index_list "]"                 (* array indexing *)
                  | field_path "[" array_index_list "]" "." field_path  (* post-index dot notation *)
                  | "count" "(" ")"
                  | "average" "(" IDENTIFIER ")"
                  | "sum" "(" IDENTIFIER ")"
                  | "product" "(" IDENTIFIER ")"

(* Field paths support dot notation for nested composite fields *)
field_path      ::= IDENTIFIER
                  | field_path "." IDENTIFIER

(* Array indexing supports single indices, slices, and combinations *)
array_index_list ::= array_index_item
                   | array_index_list "," array_index_item

array_index_item ::= INTEGER                  (* single index: [0] *)
                   | INTEGER ":" INTEGER      (* slice: [0:5] *)
                   | INTEGER ":"              (* slice from: [2:] *)
                   | ":" INTEGER              (* slice to: [:5] *)

(* Examples of array indexing:
 *   readings[0]              -- single element
 *   readings[0:5]            -- slice from index 0 to 5 (exclusive)
 *   readings[5:]             -- slice from index 5 to end
 *   readings[:5]             -- slice from start to index 5
 *   readings[0, 2, 4]        -- multiple specific indices
 *   readings[0, 2:5, 7]      -- mix of indices and slices
 *)

(* Examples of field paths:
 *   name                    -- simple field
 *   address.city            -- nested composite field
 *   address.location.lat    -- deeply nested field
 *)

(* Examples of post-index dot notation:
 *   employees[0].name       -- field of a single array element
 *   employees[0].addr.city  -- deep path after index
 *   employees[0:3].name     -- project 'name' over a slice result
 *)

(* Array projection — dotted path on an array of composites:
 *   employees.name           -- returns a list of all employee names
 *)

where_clause    ::= (* empty *)
                  | "where" condition

group_clause    ::= (* empty *)
                  | "group" "by" identifier_list

sort_clause     ::= (* empty *)
                  | "sort" "by" identifier_list

offset_clause   ::= (* empty - defaults to 0 *)
                  | "offset" INTEGER

limit_clause    ::= (* empty - no limit *)
                  | "limit" INTEGER

identifier_list ::= IDENTIFIER
                  | identifier_list "," IDENTIFIER


(* ========== WHERE Conditions ========== *)
(*
 * Conditions for filtering records.
 *
 * Examples:
 *   age >= 18
 *   name = "Alice"
 *   name starts with "A"
 *   name matches /^[A-Z]/
 *   age > 18 and age < 65
 *   not (status = "inactive")
 *)

condition       ::= IDENTIFIER comparison_op value
                  | IDENTIFIER "starts" "with" STRING
                  | IDENTIFIER "matches" REGEX
                  | "not" condition
                  | condition "and" condition
                  | condition "or" condition
                  | "(" condition ")"

comparison_op   ::= "=" | "!=" | "<" | "<=" | ">" | ">="

value           ::= INTEGER
                  | FLOAT
                  | STRING


(* ========== Eval Query (SELECT without FROM) ========== *)
(*
 * Evaluate expressions without querying a table.
 *
 * Examples:
 *   select uuid()
 *   select uuid() as "id", 42 as "answer"
 *   select 1, 2, 3
 *)

eval_query      ::= "select" eval_expr_list

eval_expr_list  ::= eval_expr_with_alias
                  | eval_expr_list "," eval_expr_with_alias

eval_expr_with_alias ::= eval_expr "as" STRING
                       | eval_expr

eval_expr       ::= STRING
                  | INTEGER
                  | FLOAT
                  | IDENTIFIER "(" ")"
                  | "uuid" "(" ")"


(* ========== SHOW TABLES Query ========== *)
(*
 * List all tables in the database.
 *
 * Example:
 *   show tables
 *)

show_tables_query ::= "show" "tables"


(* ========== DESCRIBE Query ========== *)
(*
 * Show the structure of a type.
 *
 * Example:
 *   describe Person
 *)

describe_query  ::= "describe" IDENTIFIER
                  | "describe" STRING         (* for names like "character[]" *)


(* ========== USE Query ========== *)
(*
 * Switch to a different database directory, or exit the current database.
 *
 * Examples:
 *   use example_data              -- switch to database
 *   use ./data/production         -- switch to path
 *   use /absolute/path/to/data    -- absolute path
 *   use "path with spaces"        -- quoted path
 *   use                           -- exit current database (no database selected)
 *)

use_query       ::= "use"
                  | "use" PATH
                  | "use" IDENTIFIER
                  | "use" STRING


(* ========== CREATE ALIAS Query ========== *)
(*
 * Create a type alias. The new type is stored in its own table
 * but uses the same format as the base type.
 *
 * Example:
 *   create alias uuid as uint128
 *)

create_alias_query ::= "create" "alias" IDENTIFIER "as" IDENTIFIER


(* ========== DROP DATABASE Query ========== *)
(*
 * Delete a database directory.
 *
 * Example:
 *   drop example_data
 *)

drop_database_query ::= "drop" IDENTIFIER
                      | "drop" PATH
                      | "drop" STRING


(* ========== CREATE TYPE Query ========== *)
(*
 * Create a new composite type. Fields can be on one line or multiple lines.
 *
 * Single-line example:
 *   create type Point x:float32 y:float32
 *
 * Multi-line example:
 *   create type Address
 *   street: string
 *   city: string
 *   zipcode: string
 *
 * With inheritance:
 *   create type Employee from Person department:string title:string
 *
 * Note: "string" is an alias for "character[]"
 *)

create_type_query ::= "create" "type" IDENTIFIER type_field_list
                    | "create" "type" IDENTIFIER
                    | "create" "type" IDENTIFIER "from" IDENTIFIER type_field_list
                    | "create" "type" IDENTIFIER "from" IDENTIFIER

type_field_list ::= type_field_def
                  | type_field_list type_field_def

type_field_def  ::= IDENTIFIER ":" type_ref

type_ref        ::= IDENTIFIER
                  | IDENTIFIER "[" "]"        (* array type, e.g., int8[] *)


(* ========== CREATE Instance Query ========== *)
(*
 * Create a new instance of a type.
 *
 * Examples:
 *   create Person(name="Alice", age=30)
 *   create Person(id=uuid(), name="Bob", age=25)
 *   create Contact(name="John", address=Address(0))  -- reference existing composite
 *   create Person(name="Alice", address=Address(street="123 Main", city="Springfield"))  -- inline instance
 *)

create_instance_query ::= "create" IDENTIFIER "(" instance_field_list ")"
                        | "create" IDENTIFIER "(" ")"

instance_field_list ::= instance_field
                      | instance_field_list "," instance_field

instance_field  ::= IDENTIFIER "=" instance_value

instance_value  ::= STRING
                  | INTEGER
                  | FLOAT
                  | IDENTIFIER "(" ")"
                  | "uuid" "(" ")"
                  | IDENTIFIER "(" INTEGER ")"              (* composite reference: TypeName(index) *)
                  | IDENTIFIER "(" instance_field_list ")"  (* inline instance creation *)
                  | "[" "]"                                 (* empty array *)
                  | "[" array_elements "]"                  (* array literal *)

array_elements  ::= array_element
                  | array_elements "," array_element

array_element   ::= STRING | INTEGER | FLOAT


(* ========== DELETE Query ========== *)
(*
 * Delete records from a table. Uses soft delete (zeros out records).
 *
 * Examples:
 *   delete Person where name = "Alice"
 *   delete Person where age < 18
 *   delete Person                         -- deletes all records
 *)

delete_query    ::= "delete" IDENTIFIER "where" condition
                  | "delete" IDENTIFIER
                  | "delete" STRING "where" condition    (* for names like "character[]" *)
                  | "delete" STRING


(* ========== Lexical Elements ========== *)

IDENTIFIER      ::= [a-zA-Z_][a-zA-Z0-9_]*

INTEGER         ::= -?[0-9]+

FLOAT           ::= -?[0-9]+\.[0-9]+

STRING          ::= "\"" ([^"\\] | \\.)* "\""

REGEX           ::= "/" ([^/\\] | \\.)* "/"

PATH            ::= \.?\.?/[a-zA-Z0-9_./\-]+

(* Newlines are treated as whitespace and ignored by the lexer.
 * Semicolons terminate queries in the REPL and separate queries in scripts. *)
SEMICOLON       ::= ";"


(* ========== Reserved Keywords ========== *)
(*
 * from, select, where, offset, limit, group, sort, by,
 * and, or, not, starts, with, matches, show, tables,
 * describe, count, average, sum, product, use, create,
 * type, uuid, delete, as, alias, drop
 *)


(* ========== Operator Precedence ========== *)
(*
 * From lowest to highest:
 *   1. OR
 *   2. AND
 *   3. NOT (right associative)
 *)


(* ========== Built-in Functions ========== *)
(*
 * uuid()    - Generate a random UUID (128-bit)
 * count()   - Count records (aggregate)
 * sum(f)    - Sum of field values (aggregate)
 * average(f) - Average of field values (aggregate)
 * product(f) - Product of field values (aggregate)
 *)


(* ========== Example Queries ========== *)
(*
 * -- Single queries (no semicolon needed):
 *
 * from Person select *
 *
 * from Person select name, age where age >= 21 sort by name
 *
 * from Person select age, count() group by age
 *
 * select uuid() as "id1", uuid() as "id2"
 *
 * delete Product where quantity = 0
 *
 * -- Create type (fields can be on following lines — newlines are whitespace):
 *
 * create type Product
 *   name: string
 *   price: float64
 *   quantity: uint32
 *
 * -- Multiple queries in a script (semicolons separate them):
 *
 * use example_data;
 * create type Product
 *   name: string
 *   price: float64
 *   quantity: uint32;
 * create Product(name="Widget", price=9.99, quantity=100);
 * from Product select *
 *)
