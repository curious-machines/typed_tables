(*
 * TTQ (Typed Tables Query) Language Grammar
 * =========================================
 *
 * This grammar defines the syntax for TTQ, the query language used to
 * interact with Typed Tables databases. TTQ supports selecting, filtering,
 * aggregating, creating, and deleting data.
 *
 * Newlines are treated as whitespace and are not significant — queries
 * can be formatted freely across lines. Semicolons terminate queries
 * in the interactive REPL and separate queries in scripts.
 *
 * The grammar is implemented using PLY (Python Lex-Yacc).
 *)


(* ========== Top-Level Statement ========== *)
(*
 * A statement is a query followed by a semicolon, or a bare query.
 * The grammar accepts both forms. In practice, semicolons are required
 * in the interactive REPL and in scripts with multiple queries.
 *)

statement       ::= query ";"
                  | query

query           ::= select_query
                  | eval_query
                  | show_tables_query
                  | describe_query
                  | use_query
                  | forward_type_query
                  | create_type_query
                  | create_instance_query
                  | variable_assignment_query
                  | collect_query
                  | delete_query
                  | dump_query
                  | update_query
                  | scope_block


(* ========== SELECT Query (with FROM) ========== *)
(*
 * The main query type for retrieving data from tables.
 * A SELECT clause is always required after FROM.
 *
 * Examples:
 *   from Person select *
 *   from Person select name, age
 *   from Person select * where age >= 18 sort by name
 *   from Person select age, count() group by age
 *)

select_query    ::= from_clause select_clause where_clause group_clause
                    sort_clause offset_clause limit_clause

from_clause     ::= "from" IDENTIFIER
                  | "from" STRING            (* for names like "character[]" *)
                  | "from" VARIABLE          (* from $var — use a variable as source *)

select_clause   ::= "select" "*"
                  | "select" field_list

field_list      ::= select_field
                  | field_list "," select_field

select_field    ::= field_path
                  | field_path "[" array_index_list "]"                 (* array indexing *)
                  | field_path "[" array_index_list "]" "." field_path  (* post-index dot notation *)
                  | method_chain_expr                                   (* method calls and aggregates *)

(* Aggregates are parsed as identifier-based function calls:
 *   count()           → aggregate, no field
 *   sum(age)          → aggregate with field name
 *   readings.min()    → array method call
 *   field.method().method()  → chained method calls
 *
 * Aggregate function names: count, average, sum, product, min, max.
 * These are NOT reserved keywords — they can also be used as field names.
 *)
method_chain_expr ::= field_path "(" ")"
                    | field_path "(" method_arg_list ")"
                    | method_chain_expr "." IDENTIFIER "(" ")"
                    | method_chain_expr "." IDENTIFIER "(" method_arg_list ")"

(* Field paths support dot notation for nested composite fields *)
field_path      ::= IDENTIFIER
                  | field_path "." IDENTIFIER

(* Array indexing supports single indices, slices, and combinations *)
array_index_list ::= array_index_item
                   | array_index_list "," array_index_item

array_index_item ::= INTEGER                  (* single index: [0] *)
                   | INTEGER ":" INTEGER      (* slice: [0:5] *)
                   | INTEGER ":"              (* slice from: [2:] *)
                   | ":" INTEGER              (* slice to: [:5] *)

(* Examples of array indexing:
 *   readings[0]              -- single element
 *   readings[0:5]            -- slice from index 0 to 5 (exclusive)
 *   readings[5:]             -- slice from index 5 to end
 *   readings[:5]             -- slice from start to index 5
 *   readings[0, 2, 4]        -- multiple specific indices
 *   readings[0, 2:5, 7]      -- mix of indices and slices
 *)

(* Examples of field paths:
 *   name                    -- simple field
 *   address.city            -- nested composite field
 *   address.location.lat    -- deeply nested field
 *)

(* Examples of post-index dot notation:
 *   employees[0].name       -- field of a single array element
 *   employees[0].addr.city  -- deep path after index
 *   employees[0:3].name     -- project 'name' over a slice result
 *)

(* Array projection — dotted path on an array of composites:
 *   employees.name           -- returns a list of all employee names
 *)

where_clause    ::= (* empty *)
                  | "where" condition

group_clause    ::= (* empty *)
                  | "group" "by" identifier_list

sort_clause     ::= (* empty *)
                  | "sort" "by" identifier_list

offset_clause   ::= (* empty - defaults to 0 *)
                  | "offset" INTEGER

limit_clause    ::= (* empty - no limit *)
                  | "limit" INTEGER

identifier_list ::= IDENTIFIER
                  | identifier_list "," IDENTIFIER


(* ========== WHERE Conditions ========== *)
(*
 * Conditions for filtering records.
 *
 * Examples:
 *   age >= 18
 *   name = "Alice"
 *   name starts with "A"
 *   name matches /^[A-Z]/
 *   age > 18 and age < 65
 *   not (status = "inactive")
 *)

condition       ::= IDENTIFIER comparison_op value
                  | IDENTIFIER "starts" "with" STRING
                  | IDENTIFIER "matches" REGEX
                  | "not" condition
                  | condition "and" condition
                  | condition "or" condition
                  | "(" condition ")"

comparison_op   ::= "=" | "!=" | "<" | "<=" | ">" | ">="

value           ::= INTEGER
                  | FLOAT
                  | STRING


(* ========== Eval Query (SELECT without FROM) ========== *)
(*
 * Evaluate expressions without querying a table.
 *
 * Examples:
 *   select uuid()
 *   select uuid() as "id", 42 as "answer"
 *   select 1, 2, 3
 *)

eval_query      ::= "select" eval_expr_list

eval_expr_list  ::= eval_expr_with_alias
                  | eval_expr_list "," eval_expr_with_alias

eval_expr_with_alias ::= eval_expr "as" STRING
                       | eval_expr

eval_expr       ::= STRING
                  | INTEGER
                  | FLOAT
                  | IDENTIFIER "(" ")"                      (* zero-arg function: uuid() *)
                  | IDENTIFIER "(" eval_arg_list ")"        (* function with args: sum([1,2,3]), min(5,3) *)
                  | "[" eval_expr_items "]"                 (* array literal: [1, 2, 3] *)
                  | "[" "]"                                 (* empty array: [] *)
                  | eval_expr binop eval_expr               (* arithmetic: 5 + 3, [1,2] * 3 *)
                  | "-" eval_expr                           (* unary minus *)
                  | "+" eval_expr                           (* unary plus *)
                  | "(" eval_expr ")"                       (* grouping *)

eval_arg_list   ::= eval_expr
                  | eval_arg_list "," eval_expr

eval_expr_items ::= eval_expr
                  | eval_expr_items "," eval_expr

binop           ::= "+" | "-" | "*" | "/" | "%" | "//" | "++"


(* ========== SHOW TABLES Query ========== *)
(*
 * List all tables in the database.
 *
 * Example:
 *   show tables
 *)

show_tables_query ::= "show" "tables"


(* ========== DESCRIBE Query ========== *)
(*
 * Show the structure of a type.
 *
 * Example:
 *   describe Person
 *)

describe_query  ::= "describe" IDENTIFIER
                  | "describe" STRING         (* for names like "character[]" *)


(* ========== USE Query ========== *)
(*
 * Switch to a different database directory, or exit the current database.
 *
 * Examples:
 *   use example_data              -- switch to database
 *   use ./data/production         -- switch to path
 *   use /absolute/path/to/data    -- absolute path
 *   use "path with spaces"        -- quoted path
 *   use                           -- exit current database (no database selected)
 *)

use_query       ::= "use"
                  | "use" PATH
                  | "use" IDENTIFIER
                  | "use" STRING


(* ========== CREATE ALIAS Query ========== *)
(*
 * Create a type alias. The new type is stored in its own table
 * but uses the same format as the base type.
 *
 * Example:
 *   create alias uuid as uint128
 *)

create_alias_query ::= "create" "alias" IDENTIFIER "as" IDENTIFIER


(* ========== DROP DATABASE Query ========== *)
(*
 * Delete a database directory.
 *
 * Example:
 *   drop example_data
 *)

drop_database_query ::= "drop" IDENTIFIER
                      | "drop" PATH
                      | "drop" STRING


(* ========== FORWARD TYPE Query ========== *)
(*
 * Forward-declare a type name for mutual references.
 *
 * Example:
 *   forward type B
 *
 * Mutual reference pattern:
 *   forward type B;
 *   create type A value:uint8 b:B;
 *   create type B value:uint8 a:A;
 *)

forward_type_query ::= "forward" "type" IDENTIFIER


(* ========== CREATE TYPE Query ========== *)
(*
 * Create a new composite type. Fields can be on one line or multiple lines.
 *
 * Single-line example:
 *   create type Point x:float32 y:float32
 *
 * Multi-line example:
 *   create type Address
 *   street: string
 *   city: string
 *   zipcode: string
 *
 * With inheritance:
 *   create type Employee from Person department:string title:string
 *
 * Populating a forward-declared stub:
 *   create type B a:A
 *
 * Self-referential type:
 *   create type Node value:uint8 children:Node[]
 *
 * Note: "string" is an alias for "character[]"
 *)

create_type_query ::= "create" "type" IDENTIFIER type_field_list
                    | "create" "type" IDENTIFIER "from" IDENTIFIER type_field_list
                    | "create" "type" IDENTIFIER "from" IDENTIFIER

type_field_list ::= type_field_def
                  | type_field_list type_field_def

type_field_def  ::= IDENTIFIER ":" type_ref

type_ref        ::= IDENTIFIER
                  | IDENTIFIER "[" "]"        (* array type, e.g., int8[] *)


(* ========== CREATE Instance Query ========== *)
(*
 * Create a new instance of a type.
 *
 * Examples:
 *   create Person(name="Alice", age=30)
 *   create Person(id=uuid(), name="Bob", age=25)
 *   create Contact(name="John", address=Address(0))  -- reference existing composite
 *   create Person(name="Alice", address=Address(street="123 Main", city="Springfield"))  -- inline instance
 *
 * With tag (for cyclic data, must be inside a scope block):
 *   scope { create Node(tag(A), value=1, next=A); };
 *)

create_instance_query ::= "create" IDENTIFIER "(" instance_field_list ")"
                        | "create" IDENTIFIER "(" ")"
                        | "create" IDENTIFIER "(" "tag" "(" IDENTIFIER ")" "," instance_field_list ")"
                        | "create" IDENTIFIER "(" "tag" "(" IDENTIFIER ")" ")"

instance_field_list ::= instance_field
                      | instance_field_list "," instance_field

instance_field  ::= IDENTIFIER "=" instance_value

instance_value  ::= STRING
                  | INTEGER
                  | FLOAT
                  | IDENTIFIER "(" ")"
                  | IDENTIFIER "(" INTEGER ")"              (* composite reference: TypeName(index) *)
                  | IDENTIFIER "(" instance_field_list ")"  (* inline instance creation *)
                  | IDENTIFIER "(" "tag" "(" IDENTIFIER ")" "," instance_field_list ")"  (* inline instance with tag *)
                  | "[" "]"                                 (* empty array *)
                  | "[" array_elements "]"                  (* array literal *)
                  | VARIABLE                                (* variable reference: $var *)
                  | "null"                                  (* null reference *)
                  | IDENTIFIER                              (* tag reference: bare NAME *)

array_elements  ::= array_element
                  | array_elements "," array_element

array_element   ::= STRING | INTEGER | FLOAT
                  | IDENTIFIER "(" instance_field_list ")"  (* inline instance *)
                  | VARIABLE                                (* variable reference: $var *)
                  | "null"                                  (* null reference *)


(* ========== DUMP Query ========== *)
(*
 * Serialize database contents as TTQ script, YAML, JSON, or XML.
 * Use "to" to write output to a file instead of stdout.
 * Use "pretty" for multi-line indented formatting.
 * Use "yaml" for YAML output with anchors/aliases for references.
 * Use "json" for JSON output with $id/$ref for references.
 * Use "xml" for XML output with id/ref="#id" for references.
 *
 * Examples:
 *   dump                     -- dump entire database as TTQ
 *   dump Person              -- dump single table
 *   dump to "backup.ttq"     -- dump entire database to file
 *   dump Person to "p.ttq"   -- dump single table to file
 *   dump pretty              -- pretty-print entire database
 *   dump pretty Person       -- pretty-print single table
 *   dump yaml                -- dump as YAML
 *   dump yaml pretty         -- pretty-print YAML
 *   dump yaml to "data.yaml" -- dump YAML to file
 *   dump json                -- dump as JSON
 *   dump json pretty         -- pretty-print JSON
 *   dump json to "data.json" -- dump JSON to file
 *   dump xml                 -- dump as XML
 *   dump xml pretty          -- pretty-print XML
 *   dump xml to "data.xml"   -- dump XML to file
 *)

dump_prefix     ::= "dump"
                  | "dump" "pretty"
                  | "dump" "yaml"
                  | "dump" "yaml" "pretty"
                  | "dump" "pretty" "yaml"
                  | "dump" "json"
                  | "dump" "json" "pretty"
                  | "dump" "pretty" "json"
                  | "dump" "xml"
                  | "dump" "xml" "pretty"
                  | "dump" "pretty" "xml"

dump_query      ::= dump_prefix
                  | dump_prefix IDENTIFIER
                  | dump_prefix STRING
                  | dump_prefix "to" STRING
                  | dump_prefix IDENTIFIER "to" STRING
                  | dump_prefix STRING "to" STRING
                  | dump_prefix VARIABLE
                  | dump_prefix VARIABLE "to" STRING
                  | dump_prefix "[" dump_item_list "]"
                  | dump_prefix "[" dump_item_list "]" "to" STRING

dump_item_list  ::= dump_item
                  | dump_item_list "," dump_item

dump_item       ::= IDENTIFIER                  (* table name *)
                  | STRING                       (* quoted table name *)
                  | VARIABLE                     (* variable reference *)


(* ========== Collect Query ========== *)
(*
 * Collect record indices into an immutable set variable.
 * Supports the same filtering/sorting/pagination clauses as SELECT.
 * The variable holds a list of matching record indices.
 *
 * Examples:
 *   $seniors = collect Person where age >= 65
 *   $top10 = collect Score sort by value limit 10
 *   $all = collect Person
 *)

collect_query   ::= VARIABLE "=" "collect" collect_source_list group_clause
                    sort_clause offset_clause limit_clause

collect_source_list ::= collect_source
                      | collect_source_list "," collect_source

collect_source  ::= IDENTIFIER where_clause    (* table source *)
                  | STRING where_clause         (* quoted table source *)
                  | VARIABLE where_clause       (* variable source *)


(* ========== Variable Assignment Query ========== *)
(*
 * Bind the result of a create to an immutable variable.
 * Variables can be used as field values or array elements.
 *
 * Examples:
 *   $addr = create Address(street="123 Main", city="Springfield")
 *   create Person(name="Alice", address=$addr)
 *   create Team(members=[$e1, $e2])
 *
 * With tag (for cyclic data, must be inside a scope block):
 *   scope { $n = create Node(tag(A), value=1, next=A); };
 *)

variable_assignment_query ::= VARIABLE "=" "create" IDENTIFIER "(" instance_field_list ")"
                            | VARIABLE "=" "create" IDENTIFIER "(" ")"
                            | VARIABLE "=" "create" IDENTIFIER "(" "tag" "(" IDENTIFIER ")" "," instance_field_list ")"
                            | VARIABLE "=" "create" IDENTIFIER "(" "tag" "(" IDENTIFIER ")" ")"


(* ========== DELETE Query ========== *)
(*
 * Delete records from a table. Uses soft delete (zeros out records).
 *
 * Examples:
 *   delete Person where name = "Alice"
 *   delete Person where age < 18
 *   delete Person                         -- deletes all records
 *)

delete_query    ::= "delete" IDENTIFIER "where" condition
                  | "delete" IDENTIFIER
                  | "delete" STRING "where" condition    (* for names like "character[]" *)
                  | "delete" STRING


(* ========== UPDATE Query ========== *)
(*
 * Modify fields on an existing record. The target can be a variable
 * or a direct type reference with index.
 *
 * Examples:
 *   update $n1 set next=$n2
 *   update Node(0) set next=Node(1)
 *   update $n set value=42, next=null
 *)

update_query    ::= "update" VARIABLE "set" instance_field_list
                  | "update" IDENTIFIER "(" INTEGER ")" "set" instance_field_list


(* ========== Scope Block ========== *)
(*
 * A scope block groups statements together, providing a namespace for
 * tags and variables. Tags declared inside a scope are only visible
 * within that scope.
 *
 * Scope blocks are required for using tags (cyclic data references).
 *
 * Examples:
 *   scope { create Node(tag(SELF), value=42, next=SELF); };
 *   scope { create Node(tag(A), name="A", child=Node(name="B", child=A)); };
 *)

scope_block     ::= "scope" "{" scope_statement_list "}"

scope_statement_list ::= scope_statement
                       | scope_statement_list scope_statement

scope_statement ::= query ";"


(* ========== Tag Syntax (Cyclic Data) ========== *)
(*
 * Tags allow creating cyclic data structures within a scope block.
 * A tag declares a name for the record being created that nested
 * records can reference.
 *
 * Tag declaration in create:
 *   create Type(tag(NAME), field=value, ...)
 *
 * Tag reference as field value:
 *   create Type(field=NAME)    -- NAME refers to a tagged record
 *
 * Tags must be used within a scope block. Tags cannot be redefined
 * within the same scope.
 *
 * Examples:
 *   -- Self-referencing node (points to itself):
 *   scope { create Node(tag(SELF), value=42, next=SELF); };
 *
 *   -- Two-node cycle (A→B→A):
 *   scope { create Node(tag(A), name="A", child=Node(name="B", child=A)); };
 *
 *   -- Four-node cycle (A→B→C→D→A):
 *   scope { create Node(tag(A), name="A",
 *                       child=Node(name="B",
 *                                  child=Node(name="C",
 *                                             child=Node(name="D", child=A)))); };
 *)

(* Tag declaration appears as first argument in create *)
tagged_field_list ::= "tag" "(" IDENTIFIER ")" "," instance_field_list
                    | instance_field_list

(* Tag reference - a bare IDENTIFIER as instance_value refers to a tag *)
(* This is distinguished from function calls by lookahead:
 *   IDENTIFIER "(" ... ")" is a function call or composite reference
 *   IDENTIFIER alone is a tag reference
 *)


(* ========== Lexical Elements ========== *)

VARIABLE        ::= "$" [a-zA-Z_][a-zA-Z0-9_]*

IDENTIFIER      ::= [a-zA-Z_][a-zA-Z0-9_]*

INTEGER         ::= -?[0-9]+

FLOAT           ::= -?[0-9]+\.[0-9]+

STRING          ::= "\"" ([^"\\] | \\.)* "\""

REGEX           ::= "/" ([^/\\] | \\.)* "/"

PATH            ::= \.?\.?/[a-zA-Z0-9_./\-]+

(* Newlines are treated as whitespace and ignored by the lexer.
 * Semicolons terminate queries in the REPL and separate queries in scripts. *)
SEMICOLON       ::= ";"


(* ========== Reserved Keywords ========== *)
(*
 * from, select, where, offset, limit, group, sort, by,
 * and, or, not, starts, with, matches, show, types,
 * describe, use, create, type, delete, as, alias,
 * drop, dump, to, collect, null, update, set, pretty,
 * tag, scope, forward, enum, interface, interfaces,
 * composites, enums, primitives, aliases, references,
 * graph, yaml, json, xml, compact, archive, restore,
 * execute, import, system, temp, asc, desc
 *
 * Note: count, average, sum, product, min, max are NOT
 * reserved — they are parsed as identifiers and can be
 * used as field names.
 *)


(* ========== Operator Precedence ========== *)
(*
 * From lowest to highest:
 *   1. OR
 *   2. AND
 *   3. NOT (right associative)
 *)


(* ========== Built-in Functions ========== *)
(*
 * uuid()      - Generate a random UUID (128-bit)
 * count()     - Count records (aggregate); count(arr) in eval
 * sum(f)      - Sum of field values (aggregate); sum(arr) in eval
 * average(f)  - Average of field values (aggregate); average(arr) in eval
 * product(f)  - Product of field values (aggregate); product(arr) in eval
 * min(f)      - Minimum field value (aggregate); min(arr) or min(a,b) in eval
 * max(f)      - Maximum field value (aggregate); max(arr) or max(a,b) in eval
 * sqrt(x)     - Square root
 * pow(x, y)   - Exponentiation
 * abs(x)      - Absolute value
 * ceil(x)     - Ceiling
 * floor(x)    - Floor
 * round(x)    - Round to nearest integer
 * log(x)      - Natural logarithm
 * log2(x)     - Base-2 logarithm
 * log10(x)    - Base-10 logarithm
 * sin(x), cos(x), tan(x) - Trigonometric functions
 *
 * Math functions vectorize over arrays: sqrt([1,4,9]) → [1.0,2.0,3.0]
 *)


(* ========== Example Queries ========== *)
(*
 * -- Single queries (no semicolon needed):
 *
 * from Person select *
 *
 * from Person select name, age where age >= 21 sort by name
 *
 * from Person select age, count() group by age
 *
 * select uuid() as "id1", uuid() as "id2"
 *
 * delete Product where quantity = 0
 *
 * -- Create type (fields can be on following lines — newlines are whitespace):
 *
 * create type Product
 *   name: string
 *   price: float64
 *   quantity: uint32
 *
 * -- Multiple queries in a script (semicolons separate them):
 *
 * use example_data;
 * create type Product
 *   name: string
 *   price: float64
 *   quantity: uint32;
 * create Product(name="Widget", price=9.99, quantity=100);
 * from Product select *
 *
 * -- Cyclic data structures using scope blocks and tags:
 *
 * create type Node value:uint8 next:Node;
 *
 * -- Self-referencing (node points to itself):
 * scope { create Node(tag(SELF), value=42, next=SELF); };
 *
 * -- Two-node cycle (A→B→A):
 * scope { create Node(tag(A), value=1, next=Node(value=2, next=A)); };
 *
 * -- Variables can also be used inside scopes:
 * scope { $n = create Node(tag(X), value=1, next=X); };
 *)
